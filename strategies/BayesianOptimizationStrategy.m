classdef BayesianOptimizationStrategy < handle
    
    properties
        active_models
        acquisition_function
        kernel_builder
        model
        tracker
    end
    
    methods
        function obj = BayesianOptimizationStrategy(...
                active_models, ...
                acquisition_function, ...
                kernel_builder, ...
                kernel_kernel_hyperpriors, ...
                tracker)
            
            obj.active_models = active_models;            
            obj.acquisition_function = acquisition_function;
            obj.kernel_builder = kernel_builder;
            obj.model = KernelKernelGPModel(kernel_kernel_hyperpriors);
            obj.tracker = tracker;
            
        end
        
        function next_model = query(obj, ...
                problem, ...
                selected_models, ...
                fitness_scores, ...
                candidate_models...
                )
            
            % update active models
            new_candidates_indices = ...
                obj.active_models.update(candidate_models);
            
            % pool of models
            selected_indices = obj.active_models.selected_indices;
            all_candidate_indices = 1:obj.active_models.size;
            all_candidate_indices = ...
                setdiff(all_candidate_indices, selected_indices);
            
            % update model distances using the kernel builder
            obj.kernel_builder.update(...
                obj.active_models, ...
                new_candidates_indices, ...
                all_candidate_indices, ...
                selected_indices, ...
                problem.data_X ...
                );
            
            % get kernel kernel
            K = obj.kernel_builder.get_kernel(obj.active_models.size);
            
            % making sure all necessary indices are not NaN
            KxX = K(selected_indices, all_candidate_indices);
            KXX = K(selected_indices, selected_indices);
            assert(all(~isnan(KxX(:))))
            assert(all(~isnan(KXX(:))))

            x_train = selected_indices';
            y_train = fitness_scores';
            
            % train the GP
            obj.model = obj.model.set_kernel_kernel(K);
            obj.model = obj.model.update(x_train, y_train);

            % compute acquisition function
            acquisition_function_values = obj.acquisition_function(...
                all_candidate_indices', ...
                obj.model, ...
                x_train, ...
                y_train, ...
                [] ...
                );
            
            [~, indices_acquisition] = ...
                sort(acquisition_function_values);
            
            % argmax acquisition function
            next_model_index = ...
                all_candidate_indices(indices_acquisition(end));
            next_node = obj.active_models.models{next_model_index};
            next_model = GpModel(...
                next_node.covariance, ...
                problem.hyperpriors_lowlevel);
            
            % save next model index
            obj.active_models.selected_indices = ...
                [obj.active_models.selected_indices, next_model_index];
            
            % set remove priority
            obj.active_models.remove_priority = ...
                all_candidate_indices(indices_acquisition(1:end-1));
            
            % callback tracker
            obj.tracker.callback(...
                obj, problem, candidate_models, ...
                selected_models, fitness_scores, ...
                new_candidates_indices, K, all_candidate_indices, ...
                x_train, y_train, acquisition_function_values, ...
                next_model_index...
                );
        end        
    end
end

